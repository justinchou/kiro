# 标准与方法论参考

<!-- 导航元数据 -->
<!-- 资源：标准 | 级别：参考 | 先决条件：无 -->
<!-- 相关：process/requirements-phase.md, templates/requirements-template.md, examples/simple-feature-spec.md -->

**📍 您当前所在位置：** [主指南](../../README.md) → [资源](README.md) → **标准**

## 快速导航
- **📋 应用 EARS：** [需求阶段](../process/requirements-phase.md) - 在实践中使用 EARS 格式
- **📝 使用模板：** [需求模板](../templates/requirements-template.md) - EARS 格式的模板
- **📖 查看示例：** [简单功能规格说明](../examples/simple-feature-spec.md) - EARS 实际应用
- **🔧 更多工具：** [工具与资源](tools.md) - 其他有用的资源

---

本节提供了有关行业标准、方法论和最佳实践的详细信息，这些内容为规格驱动的开发方法提供了理论基础。

## EARS (简易需求语法方法)

EARS 是一种结构化的需求编写方法，旨在使需求清晰、可测试且无歧义。它使用特定的关键字来定义不同类型的需求。

### EARS 关键字和结构

#### WHEN (事件驱动型需求)
用于由特定事件或条件触发的需求。

**格式：** `WHEN [事件/触发器] THEN [系统] SHALL [响应]`

**示例：**
- WHEN 用户点击“保存”按钮 THEN 系统 SHALL 验证所有表单字段
- WHEN 文件上传超过 10MB THEN 系统 SHALL 显示错误消息
- WHEN 用户会话过期 THEN 系统 SHALL 重定向到登录页面

#### IF (状态驱动型需求)
用于依赖特定系统状态或条件的需求。

**格式：** `IF [条件] THEN [系统] SHALL [响应]`

**示例：**
- IF 用户未通过身份验证 THEN 系统 SHALL 拒绝访问受保护的资源
- IF 数据库连接失败 THEN 系统 SHALL 显示维护消息
- IF 用户拥有管理员权限 THEN 系统 SHALL 显示管理面板

#### WHILE (持续型需求)
用于在持续操作期间必须维持的需求。

**格式：** `WHILE [条件] [系统] SHALL [持续行为]`

**示例：**
- WHILE 文件正在上传 the 系统 SHALL 显示进度指示器
- WHILE 用户正在输入 the 系统 SHALL 提供实时验证反馈
- WHILE 系统正在处理请求 the 系统 SHALL 防止重复提交

#### WHERE (可选型需求)
用于仅在特定上下文或位置应用的需求。

**格式：** `WHERE [位置/上下文] [系统] SHALL [行为]`

**示例：**
- WHERE 用户使用的是移动设备 the 系统 SHALL 使用响应式布局
- WHERE 应用程序在生产模式下运行 the 系统 SHALL 将错误记录到外部服务
- WHERE 多个用户同时编辑 the 系统 SHALL 优雅地处理冲突

### EARS 最佳实践

1. **使用主动语态**：使用主动语态编写需求，以确保清晰
2. **具体明确**：避免使用“用户友好”或“快速”等模糊术语
3. **一个语句一个需求**：每个 EARS 语句应只包含一个需求
4. **可测试的结果**：每个需求都应能通过测试进行验证
5. **术语一致**：在所有需求中使用相同的术语

### 需要避免的 EARS 反模式

- **复合需求**：避免在一个需求中使用多个 SHALL 语句
- **模糊条件**：不要使用“在适当时”等不明确的触发器
- **实现细节**：关注“做什么”，而不是“怎么做”
- **不可测试的需求**：避免使用无法衡量的主观术语

## 需求工程的行业标准

### IEEE 830 - 软件需求规格说明

IEEE 830 为编写软件需求规格说明 (SRS) 提供了指导方针。其关键原则包括：

#### 优秀需求的特征
- **正确**：准确描述预期的功能
- **无歧义**：只有一种解释
- **完整**：包含所有必要信息
- **一致**：与其他需求没有冲突
- **分级**：按重要性和稳定性进行优先级排序
- **可验证**：可以进行测试或检查
- **可修改**：可以在不产生过度影响的情况下进行更改
- **可追溯**：可以链接到设计和实现

#### SRS 文档结构
1. 引言 (目的、范围、定义)
2. 总体描述 (产品视角、功能、用户特征)
3. 具体需求 (功能性、非功能性、接口)
4. 附录 (支持信息)

### ISO/IEC 25010 - 质量需求

ISO/IEC 25010 定义了系统和软件的质量特征：

#### 功能适用性
- **功能完整性**：所有指定功能都存在
- **功能正确性**：功能提供正确的结果
- **功能适当性**：功能有助于完成指定任务

#### 性能效率
- **时间行为**：响应时间和处理速度
- **资源利用率**：CPU、内存、存储使用情况
- **容量**：最大限制和可扩展性

#### 兼容性
- **共存性**：能与其他系统一起运行
- **互操作性**：能交换和使用信息

#### 可用性
- **适宜性可识别性**：用户能识别其适用性
- **易学性**：易于学习和理解
- **易操作性**：易于操作和控制
- **用户错误防护**：防止用户出错
- **用户界面美学**：令人愉悦的用户界面
- **可访问性**：可供残障人士使用

#### 可靠性
- **成熟度**：在正常操作下满足可靠性需求
- **可用性**：在需要时可操作
- **容错性**：尽管存在硬件/软件故障仍能运行
- **可恢复性**：能从故障中恢复

#### 安全性
- **保密性**：确保只有授权用户才能访问数据
- **完整性**：防止未经授权的修改
- **不可否认性**：证明行为或事件已经发生
- **问责性**：将行为追溯到实体
- **真实性**：证明主体或资源的身份

#### 可维护性
- **模块化**：由离散组件构成
- **可重用性**：资产可用于其他系统
- **可分析性**：易于评估变更的影响
- **可修改性**：可以在不引入缺陷的情况下进行修改
- **可测试性**：可以建立测试标准

#### 可移植性
- **适应性**：能适应不同环境
- **可安装性**：能在指定环境中安装
- **可替换性**：能替换其他具有相同用途的软件

## 系统设计与架构最佳实践

### 架构原则

#### SOLID 原则
- **单一职责**：每个模块只有一个变更原因
- **开闭原则**：对扩展开放，对修改关闭
- **里氏替换**：子类型必须可以替换其基类型
- **接口隔离**：客户端不应依赖未使用的接口
- **依赖倒置**：依赖抽象，而非具体实现

#### 设计模式
- **创建型**：工厂、生成器、单例
- **结构型**：适配器、装饰器、外观
- **行为型**：观察者、策略、命令

#### 架构风格
- **分层架构**：通过分层实现关注点分离
- **微服务**：由小型、独立服务组成的分布式系统
- **事件驱动**：组件通过事件进行通信
- **六边形**：将核心逻辑与外部关注点隔离

### 系统设计方法论

#### 领域驱动设计 (DDD)
- **通用语言**：技术专家和领域专家共享的词汇表
- **限界上下文**：围绕领域模型的清晰边界
- **聚合**：业务规则的一致性边界
- **领域事件**：捕获重要的业务事件

#### 清洁架构
- **独立性**：框架、数据库和 UI 相互独立
- **可测试性**：业务规则可以在没有外部元素的情况下进行测试
- **UI 独立性**：UI 可以在不改变业务规则的情况下进行更改
- **数据库独立性**：业务规则不与数据库绑定

#### 十二要素应用
1. **代码库**：一个在版本控制中跟踪的代码库
2. **依赖**：显式声明和隔离依赖
3. **配置**：在环境中存储配置
4. **后端服务**：将后端服务视为附加资源
5. **构建、发布、运行**：严格分离构建和运行阶段
6. **进程**：作为一个或多个无状态进程执行
7. **端口绑定**：通过端口绑定导出服务
8. **并发**：通过进程模型进行扩展
9. **可处置性**：通过快速启动和优雅关闭最大化鲁棒性
10. **开发/生产环境等价**：保持开发、预发布和生产环境尽可能相似
11. **日志**：将日志视为事件流
12. **管理进程**：将管理/维护任务作为一次性进程运行

## 需求工程方法论

### 敏捷需求工程

#### 用户故事
**格式：** `作为一个 [角色]，我想要 [功能]，以便 [收益]`

**特征：**
- **独立**：可以单独开发
- **可协商**：细节可以讨论和完善
- **有价值**：为用户或业务提供价值
- **可估算**：可以为规划估算大小
- **小**：可以在一次迭代中完成
- **可测试**：有明确的验收标准

#### 验收标准
- 定义用户故事何时完成
- 以 Given-When-Then 格式或 EARS 格式编写
- 应可测试且具体
- 由团队和利益相关者共同商定

### 行为驱动开发 (BDD)

#### Gherkin 语法
```gherkin
功能：用户认证
  作为一个用户
  我想要登录系统
  以便我可以访问我的个人数据

  场景：成功登录
    假设 我在登录页面
    当 我输入有效的凭据
    那么 我应该被重定向到仪表板
```

#### BDD 流程
1. **发现**：探索和理解需求
2. **构思**：记录示例和场景
3. **自动化**：创建可执行的规格说明

### 基于模型的需求工程

#### 用例建模
- **参与者**：与系统交互的外部实体
- **用例**：特定的交互或功能
- **关系**：包含、扩展和泛化

#### 需求建模技术
- **实体关系图**：数据关系
- **状态图**：系统随时间变化的行为
- **序列图**：组件之间的交互
- **活动图**：工作流和流程

## 质量保证标准

### 测试标准

#### ISO/IEC/IEEE 29119 - 软件测试
- **测试规划**：策略和方法
- **测试设计**：测试用例和规程
- **测试执行**：运行测试并记录结果
- **测试监控**：进度跟踪和报告

#### 测试驱动开发 (TDD)
1. **红灯**：编写一个失败的测试
2. **绿灯**：编写最少的代码以通过测试
3. **重构**：在保持测试通过的同时改进代码

### 代码质量标准

#### 清洁代码原则
- **有意义的名称**：使用揭示意图的名称
- **小函数**：函数应该只做一件事
- **注释**：代码应自文档化
- **错误处理**：优雅地处理错误
- **格式化**：一致的代码格式

#### 代码审查标准
- **功能性**：代码是否按预期工作？
- **设计**：代码设计是否良好且适当？
- **复杂性**：代码是否比必要的更复杂？
- **测试**：代码是否有正确且设计良好的测试？
- **命名**：名称是否清晰且适当？
- **注释**：注释是否清晰且有用？

## 文档标准

### 技术写作最佳实践

#### 结构与组织
- **逻辑流程**：信息按逻辑顺序呈现
- **格式一致**：文档结构统一
- **清晰的标题**：描述性的章节和小节标题
- **交叉引用**：相关信息之间的链接

#### 写作风格
- **主动语态**：使用主动语态以确保清晰
- **简洁的语言**：消除不必要的词语
- **术语一致**：始终使用相同的术语
- **了解受众**：为目标受众写作

### 文档类型

#### API 文档
- **端点描述**：清晰解释每个端点
- **请求/响应示例**：输入和输出示例
- **错误代码**：全面的错误处理信息
- **认证**：安全要求和实现

#### 用户文档
- **入门指南**：快速入门指南和教程
- **功能指南**：详细的功能解释
- **故障排除**：常见问题和解决方案
- **常见问题解答**：常见问题及答案

---

## 参考与延伸阅读

### 标准组织
- **IEEE** (电气和电子工程师协会): [ieee.org](https://www.ieee.org)
- **ISO** (国际标准化组织): [iso.org](https://www.iso.org)
- **W3C** (万维网联盟): [w3.org](https://www.w3.org)

### 需求工程资源
- 《软件需求》作者：Karl Wiegers 和 Joy Beatty
- 《编写有效的用例》作者：Alistair Cockburn
- 《用户故事应用》作者：Mike Cohn
- 《实例化需求》作者：Gojko Adzic

### 系统设计资源
- 《整洁架构》作者：Robert C. Martin
- 《领域驱动设计》作者：Eric Evans
- 《构建微服务》作者：Sam Newman
- 《系统设计面试》作者：Alex Xu

### 质量保证资源
- 《代码整洁之道》作者：Robert C. Martin
- 《软件测试的艺术》作者：Glenford Myers
- 《持续交付》作者：Jez Humble 和 David Farley
- 《发布！》作者：Michael Nygard

---

[← 返回资源](README.md) | [工具和模板 →](../templates/README.md)