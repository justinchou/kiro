# 故障排除和常见陷阱

<!-- 导航元数据 -->
<!-- 示例：故障排除 | 级别：问题解决 | 先决条件：process/README.md -->
<!-- 相关：prompting/best-practices.md, execution/troubleshooting.md, case-studies.md -->

**📍 当前位置：** [主指南](../../README.md) → [示例](README.md) → **故障排除和陷阱**

## 快速导航
- **📋 学习流程：** [流程指南](../process/README.md) - 通过系统方法避免陷阱
- **💬 更好的沟通：** [提示最佳实践](../prompting/best-practices.md) - 防止误解
- **⚡ 实施问题：** [执行故障排除](../execution/troubleshooting.md) - 修复编码问题
- **📖 真实示例：** [案例研究](case-studies.md) - 从实际失败中学习

---

一个关于如何避免规范驱动开发中常见错误以及在出现问题时如何恢复的全面指南。

## 各阶段常见陷阱

### 需求阶段陷阱

#### 1. 模糊或不明确的需求

**问题：**
```markdown
# 糟糕的示例
- 用户应该能够管理他们的数据
- 系统应该快速且可靠
- 界面应该用户友好
```

**为什么会失败：**
- 没有可衡量的标准
- 主观术语没有定义
- 缺少具体的用户操作

**解决方案：**
```markdown
# 好的示例
**用户故事：** 作为一个注册用户，我想编辑我的个人资料信息，以便保持我的账户信息最新。

#### 验收标准
1. 当用户点击"编辑个人资料"时，系统应显示一个包含当前个人资料数据的可编辑表单
2. 当用户提交有效的个人资料更改时，系统应在2秒内保存这些更改
3. 当用户输入无效数据时，系统应在表单中显示具体的错误消息
```

**恢复策略：**
- 审查每个需求并问"我如何测试这个？"
- 将主观术语转换为可衡量的标准
- 添加具体的用户操作和系统响应

#### 2. 初始阶段的需求范围蔓延

**问题：**
从"简单的用户登录"开始，最后变成"完整的用户管理系统，包括角色、权限、审计日志和社交认证"。

**为什么会失败：**
- 失去对核心功能的关注
- 使设计阶段变得压倒性
- 创建不切实际的实施时间表

**解决方案：**
- 为当前规范定义明确的边界
- 单独记录"未来增强功能"
- 使用"可以/应该/必须"优先级框架

**恢复策略：**
```markdown
## 当前规范范围（必须有）
- 基本的电子邮件/密码认证
- 用户会话管理
- 密码重置功能

## 未来增强功能（可以有）
- 社交登录集成
- 基于角色的权限
- 审计日志
```

#### 3. 遗漏错误和边缘情况

**问题：**
只记录"正常路径"场景。

**常见遗漏情况：**
- 网络故障
- 无效输入处理
- 并发用户操作
- 系统资源限制

**解决方案：**
对每个需求，明确考虑：
- 当这个失败时会发生什么？
- 边界条件是什么？
- 系统在压力下应该如何表现？

### 设计阶段陷阱

#### 1. 初始设计过度工程化

**问题：**
```markdown
# 糟糕的示例 - 对于初始实施过于复杂
## 架构
- 带事件溯源的微服务
- CQRS模式实现
- 分布式缓存层
- 消息队列系统
- 带速率限制的API网关
```

**为什么会失败：**
- 增加不必要的复杂性
- 使实施任务变得压倒性
- 增加实施失败的机会

**解决方案：**
```markdown
# 好的示例 - 适合需求
## 架构
- 具有清晰模块分离的单一服务
- 带连接池的直接数据库访问
- RESTful API端点
- 简单的认证中间件
```

**恢复策略：**
- 根据实际需求审查每个设计决策
- 问"满足需求的最简单解决方案是什么？"
- 将复杂功能记录为"未来架构演进"

#### 2. 技术研究不足

**问题：**
在不了解以下内容的情况下做出设计决策：
- 可用的库和框架
- 性能特征
- 集成要求
- 部署约束

**警告信号：**
- 设计假设不存在的功能
- 没有考虑技术限制
- 缺少集成细节

**解决方案：**
- 在设计阶段研究关键技术决策
- 通过概念验证代码验证假设
- 记录技术约束及其影响

#### 3. 设计-实施差距

**问题：**
创建理论上合理但实际上难以实施的设计。

**常见问题：**
- 复杂的数据关系没有清晰的实施路径
- 假设存在不存在的库或服务
- 性能要求没有实施策略

**恢复策略：**
- 考虑实施可行性审查设计
- 将复杂组件分解为更简单、可实施的部分
- 为复杂设计决策添加实施说明

### 任务阶段陷阱

#### 1. 任务过大或模糊

**问题：**
```markdown
# 糟糕的示例
- [ ] 实现用户认证系统
- [ ] 创建数据库层
- [ ] 构建API端点
```

**为什么会失败：**
- 没有明确的完成标准
- 单个任务工作量过大
- 依赖关系不明确

**解决方案：**
```markdown
# 好的示例
- [ ] 1.1 创建带验证的用户模型
  - 实现带电子邮件、密码字段的用户类
  - 添加电子邮件格式验证
  - 添加密码强度要求
  - 为用户模型验证编写单元测试
  - _需求: 1.2, 2.1_

- [ ] 1.2 实现密码哈希工具
  - 使用bcrypt创建密码哈希函数
  - 创建密码验证函数
  - 为密码工具编写单元测试
  - _需求: 1.2, 3.1_
```

**恢复策略：**
- 将大任务分解为2-4小时的实施块
- 添加具体的可交付成果和测试标准
- 确保每个任务都有明确的完成定义

#### 2. 缺少任务依赖关系

**问题：**
由于先决工作未完成而无法实施的任务。

**示例：**
```markdown
- [ ] 2.1 实现用户登录端点
- [ ] 2.2 添加认证中间件
- [ ] 1.1 创建用户模型  # 应该先做！
```

**解决方案：**
- 审查任务序列的逻辑依赖关系
- 确保首先实施基础组件
- 使用反映实施顺序的任务编号

#### 3. 没有集成或端到端任务

**问题：**
所有任务都集中在单个组件上，没有将它们连接在一起。

**缺失元素：**
- 组件之间的集成
- 端到端工作流测试
- 系统级验证

**解决方案：**
始终包含集成任务：
```markdown
- [ ] 5.1 将认证与API端点集成
- [ ] 5.2 创建端到端用户注册流程
- [ ] 5.3 测试完整的登录/注销工作流
```

## 流程级陷阱

### 1. 跳过阶段之间的用户审批

**问题：**
在没有用户验证的情况下从需求 → 设计 → 任务移动。

**为什么会失败：**
- 在各个阶段累积错误
- 用户发现问题时已经太晚，无法有效修复
- 实施不符合用户期望

**恢复策略：**
- 在进入下一阶段之前始终获得明确的批准
- 如果后来发现问题，返回到适当的阶段
- 不要试图在实施过程中修复根本问题

### 2. 将规范视为不可变

**问题：**
当实施揭示问题时拒绝更新需求或设计。

**更好的方法：**
- 规范是可以更新的活文档
- 实施见解应该为规范改进提供信息
- 记录更改和理由以供将来参考

### 3. 完美主义瘫痪

**问题：**
花费太多时间完善需求或设计，而不是向前推进。

**警告信号：**
- 多次修订但没有显著改进
- 在小决策上分析瘫痪
- 避免实施阶段

**恢复策略：**
- 为每个阶段设置时间限制
- 追求"足够好"而不是完美
- 记住实施将揭示需要改进的领域

## 恢复策略

### 当需求从根本上有缺陷时

**症状：**
- 设计阶段揭示重大差距
- 需求之间相互冲突
- 用户反馈表明误解

**恢复步骤：**
1. 停止当前阶段工作
2. 带着已识别的具体问题返回需求
3. 仅关注问题区域的修订
4. 在继续之前获得明确的批准

### 当设计不支持需求时

**症状：**
- 任务阶段揭示实施不可能
- 设计复杂性远超需求复杂性
- 缺少关键系统组件

**恢复步骤：**
1. 识别具体的设计-需求不匹配
2. 修改设计以解决差距
3. 简化过度工程化的组件
4. 根据所有需求验证修改后的设计

### 当任务无法实施时

**症状：**
- 任务需要不存在的功能
- 任务依赖关系是循环的或不清晰的
- 单个任务太大或模糊

**恢复步骤：**
1. 根据设计和需求审查任务
2. 将大任务分解为可实施的块
3. 重新排序任务以尊重依赖关系
4. 添加缺失的集成和测试任务

## 预防策略

### 需求阶段预防
- 一致使用EARS格式
- 包括错误情况和边缘条件
- 为每个需求获取具体示例
- 与潜在用户验证需求

### 设计阶段预防
- 在设计期间研究技术决策
- 保持初始设计简单且可扩展
- 记录假设和约束
- 经常根据需求验证设计

### 任务阶段预防
- 确保每个任务是2-4小时的工作
- 包括测试和集成任务
- 按依赖顺序排序任务
- 为每个任务引用具体需求

## 需要注意的警告信号

### 早期警告信号
- 难以向他人解释需求
- 在没有研究的情况下做出设计决策
- 任务看起来压倒性或不清晰
- 抗拒在阶段之间移动

### 关键警告信号
- 同一阶段多次失败尝试
- 复杂性增加但没有增加价值
- 实施持续失败
- 用户对规范内容感到困惑

## 何时重新开始

有时最好的恢复策略是带着经验教训重新开始：

**考虑重新开始的情况：**
- 对用户需求的根本误解
- 技术方法完全错误
- 规范变得太复杂而无法遵循
- 花在修复上的时间多于向前推进

**如何有效重新开始：**
1. 记录从失败尝试中学到的经验
2. 识别失败的根本原因
3. 从简化的范围开始
4. 从一开始就应用预防策略

---

[← 返回示例](README.md) | [查看案例研究 →](case-studies.md)