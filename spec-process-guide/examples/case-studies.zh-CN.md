# 案例研究：故障排除与陷阱

<!-- 导航元数据 -->
<!-- 示例：案例研究 | 级别：故障排除 | 先决条件：simple-feature-spec.md -->
<!-- 相关：process/README.md, prompting/best-practices.md, execution/troubleshooting.md -->

**📍 您在这里：** [主指南](../../README.md) → [示例](README.md) → **案例研究**

## 快速导航
- **📖 学习基础：** [简单功能规范](simple-feature-spec.md) - 首先查看好的示例
- **📋 流程帮助：** [流程指南](../process/README.md) - 通过系统化方法避免陷阱
- **💬 更好的提示：** [最佳实践](../prompting/best-practices.md) - 更有效地沟通
- **⚡ 执行问题：** [故障排除指南](../execution/troubleshooting.md) - 修复实现问题

---

本节记录了从真实世界的规范驱动开发经验中总结的常见错误、失败方法和经验教训。从这些陷阱中学习可以帮助您避免类似问题，并在问题出现时进行恢复。

## 常见陷阱及如何避免

### 需求阶段的陷阱

#### 陷阱 1：模糊或含糊的需求

**问题所在：**
一个团队将需求规定为“系统应该快速且用户友好”。这导致在实现过程中就什么是可接受的性能和可用性产生了分歧。

**不良需求示例：**
```markdown
### 需求 1
**用户故事：** 作为用户，我希望应用程序速度快，以便获得良好的体验。

#### 验收标准
1. 当使用应用程序时，它应该很快
2. 当导航时，它应该是响应式的
```

**本应如何做：**
```markdown
### 需求 1
**用户故事：** 作为用户，我希望页面加载能快速完成，以便我能高效地完成任务。

#### 验收标准
1. 当加载主仪表板时，页面应在 2 秒内呈现
2. 当点击导航链接时，新页面应在 1.5 秒内加载
3. 当提交表单时，系统应在 500 毫秒内提供反馈
4. 如果网络条件不佳，系统应在 1 秒后显示加载指示器
```

**恢复策略：**
- 停止实现，返回需求澄清阶段
- 为所有主观术语定义具体、可衡量的标准
- 就具体指标获得利益相关者的同意
- 在继续之前更新需求文档

#### 陷阱 2：缺少边缘案例和错误场景

**问题所在：**
一个用户认证系统的规范没有考虑密码重置、账户锁定或并发登录场景。这导致了安全漏洞和糟糕的用户体验。

**不完整需求示例：**
```markdown
### 需求 1
**用户故事：** 作为用户，我希望用电子邮件和密码登录，以便访问我的账户。

#### 验收标准
1. 当提供正确的凭据时，系统应验证用户
2. 当提供不正确的凭据时，系统应显示错误
```

**本应如何做：**
```markdown
### 需求 1
**用户故事：** 作为用户，我希望用电子邮件和密码安全登录，以便在维护安全的同时访问我的账户。

#### 验收标准
1. 当提供正确的凭据时，系统应进行身份验证并创建会话
2. 当提供不正确的凭据时，系统应显示通用的错误消息
3. 当登录失败 5 次时，系统应暂时锁定账户 15 分钟
4. 当已在别处登录时，系统应适当地处理并发会话
5. 如果账户被锁定，系统应提供密码重置选项
6. 当会话过期时，系统应要求重新进行身份验证
```

**恢复策略：**
- 对所有失败场景进行系统性审查
- 为每个用户故事考虑“不愉快的路径”
- 添加安全和边缘案例需求
- 如果处理敏感数据，请与安全专家一起审查

#### 陷阱 3：技术特定的需求

**问题所在：**
需求规定“系统必须使用 React 和 Node.js”，而不是关注功能性需求。这限制了设计的灵活性，并使规范的可重用性降低。

**技术耦合需求示例：**
```markdown
### 需求 1
**用户故事：** 作为开发人员，我希望前端使用 React，以便 UI 具有交互性。

#### 验收标准
1. 构建 UI 时，应使用 React 组件
2. 处理状态时，应使用 Redux
```

**本应如何做：**
```markdown
### 需求 1
**用户故事：** 作为用户，我希望有一个交互式的 Web 界面，以便我能高效地管理我的数据。

#### 验收标准
1. 与表单交互时，更改应立即反映，无需刷新页面
2. 数据更新时，界面应自动更新
3. 使用界面时，它应在现代 Web 浏览器上工作
4. 如果禁用了 JavaScript，核心功能仍应可访问
```

**恢复策略：**
- 将功能性需求与实现选择分开
- 将技术决策移至设计阶段
- 将需求重点放在用户价值和业务成果上
- 允许设计阶段评估技术选项

### 设计阶段的陷阱

#### 陷阱 4：从一开始就过度工程

**问题所在：**
一个简单的内容管理功能在了解实际使用模式之前，就设计了微服务、事件溯源和复杂的缓存层。

**过度工程设计示例：**
```markdown
## 架构
内容管理系统将使用：
- 5 个具有独立数据库的微服务
- 对所有数据更改使用事件溯源
- 用于分布式缓存的 Redis 集群
- 用于所有服务间通信的消息队列
- 用于内容搜索的 Elasticsearch
```

**本应如何做：**
```markdown
## 架构
内容管理系统将从以下开始：
- 具有清晰模块边界的单一服务
- 具有适当索引的传统数据库
- 对频繁访问的内容进行简单缓存
- 模块之间的直接 API 调用
- 最初使用数据库全文搜索

## 未来的扩展考虑
- 模块边界设计为支持未来的服务提取
- 数据库模式设计为在需要时支持事件溯源
- 缓存层抽象以支持分布式缓存
- API 设计支持未来的微服务架构
```

**恢复策略：**
- 从满足需求的最简单设计开始
- 为未来的可扩展性进行设计，但不要立即实现它
- 在需要复杂性时规划清晰的升级路径
- 专注于解决当前问题，而不是假设的未来问题

#### 陷阱 5：错误处理设计不足

**问题所在：**
一个支付处理系统的设计侧重于“愉快的路径”，但没有充分规划网络故障、超时场景或部分支付状态。

**不完整的错误处理示例：**
```markdown
## 支付处理流程
1. 验证支付信息
2. 收取支付款项
3. 更新订单状态
4. 发送确认电子邮件
```

**本应如何做：**
```markdown
## 支付处理流程

### 愉快的路径
1. 验证支付信息
2. 收取支付款项
3. 更新订单状态
4. 发送确认电子邮件

### 错误场景
- **验证失败**：返回特定的字段错误，记录尝试
- **支付被拒**：存储尝试，提供替代支付方式
- **网络超时**：实现带指数退避的重试
- **部分收费**：实现幂等性密钥、对账流程
- **数据库故障**：将状态更新排队，实现最终一致性
- **电子邮件失败**：将电子邮件排队重试，不要使支付失败

### 恢复机制
- 对瞬时故障自动重试
- 用于支付差异的手动对账工具
- 用于解决支付问题的客户服务工具
```