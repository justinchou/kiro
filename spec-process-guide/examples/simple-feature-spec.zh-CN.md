# 简单功能规范示例

<!-- 导航元数据 -->
<!-- 示例：简单功能 | 级别：完整示例 | 先决条件：methodology/README.md -->
<!-- 相关：templates/README.md, process/README.md, complex-system-spec.md -->

**📍 当前位置：** [主指南](../../README.md) → [示例](README.md) → **简单功能规范**

## 快速导航
- **📚 首先学习：** [方法论概述](../methodology/README.md) - 理解基础
- **📝 使用模板：** [模板](../templates/README.md) - 创建你自己的规范
- **📋 遵循流程：** [流程指南](../process/README.md) - 分步说明
- **🏗️ 复杂示例：** [复杂系统规范](complex-system-spec.md) - 更高级的示例

---

本节提供了基础功能的完整规范示例，展示了三阶段方法论在实践中的应用。每个示例都包含完整的需求、设计和任务文档，以及解释关键决策的评注。

## 示例1：用户认证系统

### 概述
一个基本的用户认证系统，允许用户注册、登录和管理他们的会话。此示例演示了如何规范许多应用程序所需的基础功能。

### 完整规范文档

#### 需求文档

```markdown
# 用户认证系统 - 需求

## 引言
此功能实现了一个安全的用户认证系统，允许用户创建账户、安全登录并维持认证会话。该系统将处理用户注册、登录验证、会话管理和基本的安全措施。

## 需求

### 需求 1
**用户故事：** 作为一个新用户，我希望用电子邮件和密码创建一个账户，以便访问应用程序的受保护功能。

#### 验收标准
1. 当用户提供有效的电子邮件和密码时，系统应创建一个新的用户账户。
2. 当用户提供的电子邮件已存在时，系统应返回相应的错误消息。
3. 当用户提供无效的电子邮件格式时，系统应验证并拒绝输入。
4. 当用户提供弱密码时，系统应强制执行密码强度要求。

### 需求 2
**用户故事：** 作为一个注册用户，我希望用我的凭据登录，以便访问我的账户和受保护的功能。

#### 验收标准
1. 当用户提供正确的电子邮件和密码时，系统应进行认证并创建一个会话。
2. 当用户提供不正确的凭据时，系统应返回认证错误。
3. 当用户多次尝试登录失败时，系统应实施速率限制。
4. 如果用户已经登录，系统应适当地处理现有会话。

### 需求 3
**用户故事：** 作为一个已登录的用户，我希望我的会话能够被安全地维持，以便在保持安全的同时不必频繁地重新认证。

#### 验收标准
1. 当用户成功登录时，系统应创建一个安全的会话令牌。
2. 当用户发出认证请求时，系统应验证会话令牌。
3. 当会话过期时，系统应要求重新认证。
4. 当用户注销时，系统应使会话令牌无效。
```

#### 设计文档

```markdown
# 用户认证系统 - 设计

## 概述
认证系统将使用JWT令牌实现无状态认证，并使用bcrypt进行安全的密码哈希。该系统将包括注册、登录、会话验证和注销功能，并采取适当的安全措施。

## 架构
- **认证服务**：用户管理的核心业务逻辑
- **密码服务**：安全的密码哈希和验证
- **令牌服务**：JWT令牌的生成和验证
- **用户仓库**：用户存储的数据访问层
- **认证中间件**：受保护路由的请求验证

## 组件和接口

### 用户模型
```typescript
interface User {
  id: string;
  email: string;
  passwordHash: string;
  createdAt: Date;
  lastLoginAt?: Date;
}
```

### 认证服务
```typescript
interface AuthService {
  register(email: string, password: string): Promise<User>;
  login(email: string, password: string): Promise<{ user: User; token: string }>;
  validateToken(token: string): Promise<User>;
  logout(token: string): Promise<void>;
}
```

## 数据模型
- **用户存储**：带有索引电子邮件字段的数据库表
- **会话管理**：带有过期的JWT令牌
- **速率限制**：基于内存或Redis的尝试跟踪

## 错误处理
- 输入验证错误 (400 Bad Request)
- 认证失败 (401 Unauthorized)
- 速率限制 (429 Too Many Requests)
- 服务器错误 (500 Internal Server Error)

## 测试策略
- 每个服务组件的单元测试
- 完整认证流程的集成测试
- 常见漏洞的安全测试
- 并发认证请求的性能测试
```

#### 任务文档

```markdown
# 用户认证系统 - 实施计划

- [ ] 1. 设置项目结构和依赖
  - 创建认证模块目录结构
  - 安装所需依赖（bcrypt, jsonwebtoken, 验证库）
  - 设置TypeScript接口和类型
  - _需求: 1.1, 2.1, 3.1_

- [ ] 2. 实现用户模型和验证
  - 创建用户接口和数据模型
  - 使用正则表达式实现电子邮件验证
  - 创建密码强度验证（最小长度，复杂性）
  - 为验证函数编写单元测试
  - _需求: 1.1, 1.3, 1.4_

- [ ] 3. 创建密码安全服务
  - 使用bcrypt和适当的盐轮次实现密码哈希
  - 创建用于登录验证的密码比较函数
  - 为密码哈希和验证编写单元测试
  - _需求: 1.1, 2.1_

- [ ] 4. 构建JWT令牌服务
  - 实现带有用户负载和过期的令牌生成
  - 创建令牌验证和解码功能
  - 为注销添加令牌黑名单功能
  - 为令牌操作编写单元测试
  - _需求: 2.1, 3.1, 3.2, 3.4_

- [ ] 5. 实现用户仓库层
  - 为用户表创建数据库模式和迁移
  - 实现用户管理的CRUD操作
  - 添加电子邮件唯一性约束和索引
  - 为数据库操作编写集成测试
  - _需求: 1.1, 1.2, 2.1_

- [ ] 6. 构建认证服务
  - 实现带验证和密码哈希的用户注册
  - 创建带凭据验证的登录功能
  - 为受保护的路由添加会话验证
  - 实现带令牌失效的注销
  - 为所有认证流程编写全面的单元测试
  - _需求: 1.1, 1.2, 2.1, 2.2, 3.1, 3.4_

- [ ] 7. 创建认证中间件
  - 构建中间件以验证受保护路由上的JWT令牌
  - 实现适当的错误处理和响应格式化
  - 添加带认证用户信息的请求上下文
  - 为中间件功能编写集成测试
  - _需求: 3.1, 3.2_

- [ ] 8. 实施速率限制和安全措施
  - 为每个IP/电子邮件的登录尝试添加速率限制
  - 在多次失败尝试后实施账户锁定
  - 创建安全头和CORS配置
  - 为安全措施编写测试
  - _需求: 2.3_

- [ ] 9. 创建API端点和集成
  - 为注册、登录和注销构建REST端点
  - 实现适当的HTTP状态码和错误响应
  - 添加请求/响应验证和清理
  - 编写端到端API测试
  - _需求: 1.1, 2.1, 3.4_

- [ ] 10. 添加监控和日志记录
  - 为认证事件实现结构化日志记录
  - 添加登录成功/失败率的指标
  - 为可疑认证模式创建警报
  - 为日志记录功能编写测试
  - _需求: 2.3_
```

### 关键决策评注

#### 为什么选择JWT令牌？
- **无状态**：无需服务器端会话存储
- **可扩展**：在分布式系统中表现良好
- **标准**：完善的安全实践
- **灵活**：可以包含自定义声明和过期时间

#### 为什么选择bcrypt进行密码哈希？
- **自适应**：随着硬件的改进可以增加难度
- **内置盐**：自动生成盐可防止彩虹表攻击
- **久经考验**：广泛使用和审计的安全库
- **可配置**：可调节的工作因子以平衡安全性和性能

#### 数据库设计决策
- **电子邮件作为用户名**：对用户更简单，是自然的唯一标识符
- **独立的密码哈希**：绝不存储明文密码
- **时间戳**：跟踪账户创建和最后登录以进行分析
- **索引**：为电子邮件字段建立索引以在登录期间快速查找

### 实施说明

此规范可转化为大约8-10个TypeScript文件：
- `models/User.ts` - 数据模型和接口
- `services/AuthService.ts` - 核心认证逻辑
- `services/PasswordService.ts` - 密码哈希工具
- `services/TokenService.ts` - JWT令牌管理
- `repositories/UserRepository.ts` - 数据库操作
- `middleware/AuthMiddleware.ts` - 请求认证
- `controllers/AuthController.ts` - HTTP端点处理程序
- `routes/auth.ts` - 路由定义
- `__tests__/` - 全面的测试套件

### 经验教训

**哪些做得好：**
- 将认证分解为离散的服务使测试更容易
- 从清晰的接口开始有助于保持一致性
- 系统地解决了安全问题

**可以改进的地方：**
- 本可以包含更具体的错误消息要求
- 速率限制策略可以在设计阶段更详细
- 未包含密码重置功能，但通常需要

---

## 示例2：数据验证组件

### 概述
一个可重用的数据验证组件，可以使用可自定义的规则验证不同类型的输入数据。此示例展示了如何规范将在多个功能中使用的实用程序组件。

### 完整规范文档

#### 需求文档

```markdown
# 数据验证组件 - 需求

## 引言
此功能实现了一个灵活的数据验证组件，可以根据可配置的规则验证各种类型的输入数据。该组件将支持常见的验证模式、自定义验证函数，并为失败的验证提供清晰的错误消息。

## 需求

### 需求 1
**用户故事：** 作为一名开发人员，我想要一个可以验证常见数据类型的验证组件，以便确保整个应用程序的数据完整性。

#### 验收标准
1. 当验证字符串数据时，系统应支持长度、模式和格式验证。
2. 当验证数字数据时，系统应支持范围、精度和类型验证。
3. 当验证电子邮件地址时，系统应使用标准的电子邮件格式验证。
4. 当验证日期时，系统应支持格式和范围验证。

### 需求 2
**用户故事：** 作为一名开发人员，我希望定义自定义验证规则，以便验证特定领域的数据要求。

#### 验收标准
1. 当定义自定义验证器时，系统应接受自定义验证函数。
2. 当组合多个验证器时，系统应支持验证链。
3. 当验证失败时，系统应提供特定的错误消息。
4. 如果验证通过，系统应返回已验证的数据。

### 需求 3
**用户故事：** 作为一名开发人员，我想要清晰的验证错误消息，以便向用户提供有意义的反馈。

#### 验收标准
1. 当验证失败时，系统应返回描述性的错误消息。
2. 当多个验证失败时，系统应收集所有错误消息。
3. 当显示错误时，系统应识别哪个字段验证失败。
4. 如果提供了自定义错误消息，系统应使用它们而不是默认消息。
```

#### 设计文档

```markdown
# 数据验证组件 - 设计

## 概述
验证组件将实现为一个可组合的验证系统，支持内置验证器和自定义验证函数。它将使用流畅的API来链接验证器，并提供详细的错误报告。

## 架构
- **验证器接口**：所有验证函数的通用接口
- **内置验证器**：用于常见用例的预定义验证器
- **验证链**：可组合的验证管道
- **错误收集器**：聚合和格式化验证错误
- **模式验证器**：验证具有多个字段的复杂对象

## 组件和接口

### 核心验证器接口
```typescript
interface Validator<T> {
  validate(value: T): ValidationResult;
  withMessage(message: string): Validator<T>;
}

interface ValidationResult {
  isValid: boolean;
  errors: string[];
  value?: any;
}
```

### 验证链
```typescript
interface ValidationChain<T> {
  required(): ValidationChain<T>;
  string(): ValidationChain<string>;
  number(): ValidationChain<number>;
  email(): ValidationChain<string>;
  minLength(min: number): ValidationChain<string>;
  maxLength(max: number): ValidationChain<string>;
  pattern(regex: RegExp): ValidationChain<string>;
  custom(validator: (value: T) => boolean): ValidationChain<T>;
  validate(value: T): ValidationResult;
}
```

## 数据模型
- **验证规则**：不同验证类型的配置对象
- **错误消息**：本地化的错误消息模板
- **模式定义**：具有字段级规则的对象验证模式

## 错误处理
- 一致地收集和格式化验证错误
- 支持自定义错误消息和国际化
- 用于表单验证的字段级错误映射
- 优雅地处理无效的输入类型

## 测试策略
- 每个内置验证器的单元测试
- 验证链的集成测试
- 边界条件的边缘情况测试
- 大数据集的性能测试
```

#### 任务文档

```markdown
# 数据验证组件 - 实施计划

- [ ] 1. 设置验证组件结构
  - 创建验证模块目录和核心接口
  - 为验证器和结果定义TypeScript类型
  - 设置测试框架和初始测试结构
  - _需求: 1.1, 2.1, 3.1_

- [ ] 2. 实现核心验证接口
  - 创建基础验证器接口和ValidationResult类型
  - 实现带流畅API的ValidationChain类
  - 创建错误收集和格式化工具
  - 为核心接口编写单元测试
  - _需求: 2.1, 2.2, 3.1, 3.2_

- [ ] 3. 构建内置字符串验证器
  - 实现required, minLength, maxLength验证器
  - 创建支持正则表达式的模式匹配验证器
  - 添加带全面正则表达式的电子邮件格式验证
  - 为所有字符串验证器编写单元测试
  - _需求: 1.1, 1.3_

- [ ] 4. 创建数字验证器
  - 实现数字类型验证和转换
  - 添加min, max和范围验证函数
  - 创建精度和小数位验证器
  - 为数字验证边缘情况编写单元测试
  - _需求: 1.2_

- [ ] 5. 实现日期和时间验证器
  - 创建日期格式验证和解析
  - 添加日期范围验证器（之前、之后、之间）
  - 实现时间格式验证
  - 为各种日期格式和边缘情况编写单元测试
  - _需求: 1.4_

- [ ] 6. 构建自定义验证支持
  - 实现自定义验证器函数接口
  - 为多个验证器创建验证链组合
  - 添加条件验证支持
  - 为自定义验证器集成编写单元测试
  - _需求: 2.1, 2.2_

- [ ] 7. 创建错误消息系统
  - 实现默认错误消息模板
  - 为每个验证器添加自定义错误消息支持
  - 为动态值创建错误消息插值
  - 为错误消息生成和格式化编写测试
  - _需求: 3.1, 3.2, 3.4_

- [ ] 8. 构建对象模式验证
  - 为复杂对象创建模式定义接口
  - 实现带错误映射的字段级验证
  - 添加嵌套对象验证支持
  - 为完整的对象验证编写集成测试
  - _需求: 2.2, 3.3_

- [ ] 9. 添加验证工具和帮助程序
  - 创建验证结果聚合工具
  - 为常见框架实现验证中间件
  - 添加表单验证帮助程序和集成示例
  - 编写全面的集成测试
  - _需求: 2.2, 3.3_

- [ ] 10. 性能优化和最终确定
  - 优化验证链以提高性能
  - 为已编译的正则表达式模式添加缓存
  - 创建全面的文档和用法示例
  - 编写性能测试和基准测试
  - _需求: 1.1, 2.1, 3.1_
```

### 关键决策评注

#### 为什么采用流畅API设计？
- **开发者体验**：直观的链式语法
- **可组合性**：易于组合多个验证器
- **可读性**：验证规则读起来像自然语言
- **灵活性**：可以在不破坏现有代码的情况下添加新的验证器

#### 错误收集策略
- **全面**：收集所有验证错误，而不仅仅是第一个
- **结构化**：所有验证器都有一致的错误格式
- **可定制**：允许自定义错误消息以获得更好的用户体验
- **可本地化**：支持国际化

### 实施说明

此规范产生一个模块化的验证库：
- `core/Validator.ts` - 基础接口和类型
- `core/ValidationChain.ts` - 流畅API实现
- `validators/StringValidators.ts` - 字符串验证函数
- `validators/NumberValidators.ts` - 数字验证函数
- `validators/DateValidators.ts` - 日期/时间验证函数
- `utils/ErrorCollector.ts` - 错误聚合工具
- `schema/ObjectValidator.ts` - 复杂对象验证
- `__tests__/` - 全面的测试覆盖

### 经验教训

**哪些做得好：**
- 流畅API使组件对开发人员非常友好
- 分离内置和自定义验证器提供了良好的灵活性
- 全面的错误收集改善了调试体验

**可以改进的地方：**
- 本可以更清楚地指定性能要求
- 没有考虑异步验证支持，但可能需要
- 与流行的表单库的集成可以更详细

---

## 使用指南

### 何时使用这些示例

**用户认证示例**非常适合：
- 学习如何规范安全关键功能
- 理解如何分解复杂的业务逻辑
- 查看安全要求如何转化为实施任务

**数据验证示例**非常适合：
- 理解实用程序组件规范
- 学习如何设计可重用、可组合的系统
- 查看开发者体验要求如何驱动设计决策

### 调整这些示例

两个示例都可以针对不同上下文进行调整：
- **技术栈**：在保持结构的同时替换特定技术
- **复杂性级别**：根据项目需求添加或删除功能
- **领域需求**：在维护流程的同时修改业务规则
- **集成需求**：根据现有系统架构调整接口

---

[← 返回示例概述](README.md) | [复杂系统示例 →](complex-system-spec.md)