# 需求阶段文档

<!-- 导航元数据 -->
<!-- 阶段: 需求 | 级别: 详细指南 | 先决条件: methodology/README.md -->
<!-- 相关: templates/requirements-template.md, resources/standards.md, examples/simple-feature-spec.md -->

**📍 您在这里:** [主指南](../../README.md) → [流程指南](README.md) → **需求阶段**

## 快速导航
- **🎯 快速开始:** [需求模板](../templates/requirements-template.md) - 即用型模板
- **📖 查看示例:** [简单功能规范](../examples/simple-feature-spec.md) - 完整的需求示例
- **📚 学习 EARS:** [标准参考](../resources/standards.md) - EARS 格式详情
- **➡️ 下一阶段:** [设计阶段](design-phase.md) - 需求批准后

## 阶段导航
- **上一步:** [流程概述](README.md) - 三阶段工作流
- **当前:** **需求阶段** - 将想法转化为结构化需求
- **下一步:** [设计阶段](design-phase.md) - 创建技术架构
- **最后:** [任务阶段](tasks-phase.md) - 分解为实施步骤

---

## 概述

需求阶段是规范驱动开发的基础，它将粗略的功能想法转化为清晰、可测试的需求，采用 EARS（Easy Approach to Requirements Syntax）格式。此阶段确保所有利益相关者在进入设计和实施之前，对需要构建的内容有共同的理解。

## 目的和目标

需求阶段旨在：
- 将模糊的功能想法转化为具体、可衡量的需求
- 为功能成功建立明确的验收标准
- 在利益相关者之间建立共识
-为设计和实施决策提供基础
- 实现有效的测试和验证策略

## 分步流程

### 第 1 步：初始需求生成

**目标**：根据功能想法创建需求初稿

**流程**：
1. **分析功能想法**：将核心概念分解为面向用户的功能
2. **识别用户角色**：确定谁将与该功能互动
3. **定义用户故事**：以“作为 [角色]，我希望 [功能]，以便 [好处]”的格式创建用户故事
4. **生成验收标准**：为每个用户故事编写 EARS 格式的需求

**关键原则**：
- 从用户体验出发，而非技术实现
- 关注可观察、可测试的行为
- 考虑边缘情况和错误场景
- 思考完整的用户旅程

### 第 2 步：需求结构和格式

**文档结构**：
```markdown
# 需求文档

## 引言
[功能及其目的的简要概述]

## 需求

### 需求 1
**用户故事：** 作为 [角色]，我希望 [功能]，以便 [好处]

#### 验收标准
1. 当 [事件] 发生时，则 [系统] 应 [响应]
2. 如果 [前提条件]，则 [系统] 应 [响应]
3. 当 [事件] 发生且 [条件] 满足时，则 [系统] 应 [响应]

### 需求 2
[继续添加其他需求...]
```

**EARS 格式指南**：
- **WHEN**：描述触发事件或条件
- **IF**：描述必须满足的前提条件
- **THEN**：描述系统所需的响应
- **SHALL**：表示强制性行为（保持一致使用）
- **AND/OR**：必要时组合条件

### 第 3 步：需求验证

**验证标准**：
- [ ] 每个需求都是可测试和可衡量的
- [ ] 需求覆盖了正常、边缘和错误情况
- [ ] 用户故事提供了明确的业务价值
- [ ] 验收标准是具体且无歧义的
- [ ] 需求是独立的，不相互冲突
- [ ] 涵盖了所有用户角色和互动

**常见验证问题**：
- 这个需求可以自动测试吗？
- 预期行为是否明确定义？
- 是否有需要明确说明的假设？
- 出现问题时会发生什么？
- 是否有遗漏的用户场景？

### 第 4 步：迭代优化

**优化流程**：
1. **与利益相关者审查**：获取关于完整性和准确性的反馈
2. **识别差距**：寻找缺失的场景或不明确的需求
3. **澄清模糊之处**：解决任何含糊或冲突的需求
4. **添加缺失的细节**：包括边缘情况和错误处理
5. **验证业务价值**：确保每个需求都有明确的目的

**迭代指南**：
- 一次只做一个集中的更改
- 更改后始终要求明确批准
- 记录需求决策背后的原因
- 保持需求的细节层次适当（不要太高，也不要太低）

## EARS 格式深度解析

### 基本 EARS 模式

**简单事件-响应**：
```
当 [用户点击提交按钮] 时，则 [系统] 应 [验证表单数据]
```

**条件行为**：
```
如果 [用户已认证]，则 [系统] 应 [显示用户仪表板]
```

**复杂条件**：
```
当 [用户提交表单] 且 [所有必填字段都已填写] 时，则 [系统] 应 [处理提交]
```

**错误处理**：
```
当 [用户提交无效数据] 时，则 [系统] 应 [显示特定的错误消息]
```

### 高级 EARS 模式

**基于状态的需求**：
```
当 [系统处于维护模式] 时，则 [系统] 应 [向所有用户显示维护消息]
```

**性能需求**：
```
当 [用户请求数据] 时，则 [系统] 应 [在 2 秒内响应]
```

**安全需求**：
```
如果 [用户会话过期]，则 [系统] 应 [重定向到登录页面]
```

## 格式良好的需求示例

### 示例 1：用户认证功能

**用户故事**：作为新用户，我希望创建一个帐户，以便访问个性化功能。

**验收标准**：
1. 当用户提供有效的电子邮件和密码时，则系统应创建新帐户
2. 当用户提供已存在的电子邮件时，则系统应显示“电子邮件已注册”错误
3. 当用户提供无效的电子邮件格式时，则系统应显示“无效的电子邮件格式”错误
4. 当用户提供少于 8 个字符的密码时，则系统应显示“密码太短”错误
5. 当帐户创建成功时，则系统应发送确认电子邮件
6. 当帐户创建成功时，则系统应重定向到欢迎页面

### 示例 2：数据验证功能

**用户故事**：作为用户，我希望我的输入得到验证，以免提交不正确的信息。

**验收标准**：
1. 当用户在必填字段中输入数据时，则系统应移除任何错误高亮
2. 当用户提交带有空必填字段的表单时，则系统应以红色高亮缺失的字段
3. 当用户输入无效的数据格式时，则系统应在字段下方显示格式要求
4. 当所有验证通过时，则系统应启用提交按钮
5. 如果验证失败，则系统应保持提交按钮禁用

### 示例 3：文件上传功能

**用户故事**：作为用户，我希望上传文件，以便与我的团队共享文档。

**验收标准**：
1. 当用户选择小于 10MB 的文件时，则系统应接受文件上传
2. 当用户选择大于 10MB 的文件时，则系统应显示“文件太大”错误
3. 当用户选择不支持的文件类型时，则系统应显示“不支持的格式”错误
4. 当上传正在进行时，则系统应显示进度指示器
5. 当上传成功完成时，则系统应显示成功消息
6. 当上传失败时，则系统应显示重试选项
7. 如果用户未认证，则系统应在上传前重定向到登录页面

## 常见陷阱及避免方法

### 陷阱 1：模糊的需求
**问题**：“系统应该很快”
**解决方案**：“当用户请求数据时，则系统应在 2 秒内响应”

### 陷阱 2：需求中包含实现细节
**问题**：“系统应使用 Redis 进行缓存”
**解决方案**：“当用户请求频繁访问的数据时，则系统应返回缓存结果”

### 陷阱 3：缺少错误情况
**问题**：只定义了“理想路径”场景
**解决方案**：始终为错误条件包含 WHEN/IF 语句

### 陷阱 4：冲突的需求
**问题**：相互矛盾的需求
**解决方案**：一起审查所有需求，并明确解决冲突

### 陷阱 5：不可测试的需求
**问题**：“系统应该用户友好”
**解决方案**：“当新用户完成入门引导时，则系统应要求不超过 3 次点击即可到达主要功能”

## 质量清单

在进入设计阶段之前，请验证：

**完整性**：
- [ ] 所有用户角色都已识别和处理
- [ ] 覆盖了正常、边缘和错误情况
- [ ] 所有用户互动都有定义的系统响应
- [ ] 业务规则和约束已被捕获

**清晰性**：
- [ ] 每个需求都使用精确、无歧义的语言
- [ ] 避免或明确定义了技术术语
- [ ] 需求从用户角度编写
- [ ] 预期行为是具体和可衡量的

**一致性**：
- [ ] EARS 格式在整个文档中保持一致使用
- [ ] 术语在所有需求中保持一致
- [ ] 需求不相互矛盾
- [ ] 类似场景的处理方式相似

**可测试性**：
- [ ] 每个需求都可以通过测试进行验证
- [ ] 成功标准是可观察和可衡量的
- [ ] 需求指定了输入和预期输出
- [ ] 验收标准足够具体，可以指导测试创建

## 常见问题排查

### 问题：需求不断增长
**症状**：审查期间不断有新需求被添加
**解决方案**：尽早设定范围边界，并将范围外的项目记录下来以备将来迭代

### 问题：利益相关者意见不一
**症状**：不同利益相关者想要相互冲突的功能
**解决方案**：促进讨论以了解根本需求，并找到折衷方案

### 问题：需求过于技术化
**症状**：需求关注于实现而非用户需求
**解决方案**：从用户角度重构需求，并将技术细节移至设计阶段

### 问题：需求过于模糊
**症状**：无法测试或衡量的验收标准
**解决方案**：问“我们如何知道这个需求已满足？”，并使标准更具体

## 后续步骤

需求完成并获批后：
1. **过渡到设计阶段**：以需求为基础进行系统设计
2. **保持可追溯性**：确保设计决策能追溯到具体需求
3. **保持需求更新**：如果设计揭示了差距或冲突，则更新需求
4. **准备实施**：需求将指导任务分解和测试策略

需求阶段为之后的一切奠定了基础。花时间把需求做好，可以在设计和实施阶段节省大量精力。